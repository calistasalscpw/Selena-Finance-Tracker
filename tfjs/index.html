<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TensorFlow.js Model Training and Anomaly Detection</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
  <h1>TensorFlow.js Model Training and Anomaly Detection</h1>

  <script>
    // Fungsi untuk memuat model
    async function loadModel() {
      const modelUrl = './my-autoencoder.json';  // Ganti dengan path ke model .json kamu
      try {
        const model = await tf.loadLayersModel(modelUrl);
        console.log('Model berhasil dimuat:', model);
        return model;
      } catch (error) {
        console.error('Terjadi kesalahan saat memuat model:', error);
        return null;
      }
    }

    // Fungsi untuk melatih model
    async function trainModel(model, trainData, epochs = 10) {
      model.compile({
        optimizer: tf.train.adam(),
        loss: 'meanSquaredError',
      });

      const batchSize = 32;

      // Latih model
      for (let epoch = 0; epoch < epochs; epoch++) {
        const history = await model.fit(trainData, trainData, {
          epochs: 1,
          batchSize: batchSize,
          validationSplit: 0.1,
          shuffle: true,
        });

        console.log(`Epoch ${epoch + 1}: loss = ${history.history.loss[0]}`);
      }

      console.log('Pelatihan selesai!');
      return model;
    }

    // Fungsi untuk preprocessing data dan mengembalikan nilai min dan max
    function preprocessData(rawData) {
      const processedData = rawData.map(entry => {
        const date = new Date(entry.date);
        const dayOfWeek = date.getDay();
        const month = date.getMonth();
        const dayOfMonth = date.getDate();
        const year = date.getFullYear();
        const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);

        return [entry.amount, dayOfWeek, month, dayOfMonth, year, dayOfYear];
      });

      const dataTensor = tf.tensor2d(processedData);
      const minValues = dataTensor.min(0);
      const maxValues = dataTensor.max(0);
      const normalizedData = dataTensor.sub(minValues).div(maxValues.sub(minValues));

      // Mengembalikan data normalisasi dan nilai min/max
      return { normalizedData, minValues, maxValues, processedData };
    }

    // Fungsi untuk mendeteksi anomali berdasarkan reconstruction error dan mengembalikan hasil dalam format JSON
    async function detectAnomalies(model, dataTensor, minValues, maxValues, processedData, percentile = 97) {
      // Prediksi menggunakan model
      const predictedData = model.predict(dataTensor);

      // Menghitung reconstruction error (selisih antara input dan output)
      const reconstructionError = dataTensor.sub(predictedData).square().sum(1);

      // Ambil array dari reconstruction error
      const errorArray = await reconstructionError.data();

      // Urutkan error untuk mendapatkan threshold persentil yang ditentukan
      const sortedErrors = errorArray.sort((a, b) => a - b);
      const threshold = sortedErrors[Math.floor(sortedErrors.length * (percentile / 100))];

      // Menyaring data yang lebih besar dari threshold
      const anomalies = [];
      for (let i = 0; i < errorArray.length; i++) {
        if (errorArray[i] > threshold) {
          // Denormalisasi data
          const denormalizedData = dataTensor.slice([i, 0], [1, -1])
            .mul(maxValues.sub(minValues))
            .add(minValues);

          // Ambil data dari hasil denormalisasi dan masukkan kembali kolom 'date'
          const denormalizedArray = denormalizedData.arraySync()[0];

          const anomaly = {
            index: i,
            data: {
              amount: denormalizedArray[0],  // amount
            },
            reconstruction_error: errorArray[i],  // Tambahkan nilai error
          };

          // Konversi kembali ke tanggal (menggunakan data yang denormalisasi)
          const { amount } = anomaly.data;
          const date = new Date(denormalizedArray[4], denormalizedArray[2], denormalizedArray[3]);  // Menggunakan data year, month, day_of_month
          
          // Format tanggal menjadi yyyy-mm-dd
          const formattedDate = date.toISOString().split('T')[0];  // Mengambil tanggal dalam format yyyy-mm-dd
          anomaly.data.date = formattedDate;

          // Menambahkan hasil anomali yang lengkap ke daftar anomali
          anomalies.push(anomaly);
        }
      }

      // Mengembalikan data anomali dalam format JSON
      return JSON.stringify(anomalies, null, 2);  // Menggunakan JSON.stringify untuk format yang lebih baik
    }

    // Fungsi untuk memuat data dari file JSON
    async function loadDataFromJson() {
      const response = await fetch('./pengeluaran.json');
      const data = await response.json();
      return data;
    }

    // Fungsi utama untuk memuat, melatih, dan mendeteksi anomali
    async function main() {
      const model = await loadModel();

      // Memuat data dari file JSON
      const rawData = await loadDataFromJson();

      // Proses data
      const { normalizedData, minValues, maxValues, processedData } = preprocessData(rawData);

      // Latih model
      await trainModel(model, normalizedData, 50);  // Melatih model selama 50 epoch

      // Setelah pelatihan, simpan model
      await model.save('localstorage://my-autoencoder');

      // Deteksi anomali dengan persentil yang ditentukan (misalnya, 95)
      const anomaliesJson = await detectAnomalies(model, normalizedData, minValues, maxValues, processedData, 99);

      // Menampilkan hasil deteksi anomali dalam bentuk JSON
      console.log('Data anomali (dalam format JSON):');
      console.log(anomaliesJson);  // Menampilkan daftar anomali dalam format JSON
    }

    // Panggil fungsi utama
    main();
  </script>
</body>
</html>
